<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>努力吧少年!</title>
  
  <subtitle>What hurts more, the pain of hard work or the pain of regret?</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fafe.me/"/>
  <updated>2017-10-01T16:24:35.738Z</updated>
  <id>https://fafe.me/</id>
  
  <author>
    <name>johnj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Discuz X 3.4 由任意文件删除到 Getshell</title>
    <link href="https://fafe.me/2017/10/02/discuz-getshell/"/>
    <id>https://fafe.me/2017/10/02/discuz-getshell/</id>
    <published>2017-10-01T16:14:34.000Z</published>
    <updated>2017-10-01T16:24:35.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>先下载官方托管在码云上的 Discuz X 源码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://gitee.com/ComsenzDiscuz/DiscuzX.git</div></pre></td></tr></table></figure><p>查看其提交历史，发现有一个『优化 加强安全性』的 commit 比较可疑：<br><img src="截图 2017-10-01 21时29分18秒.jpg" alt="截图 2017-10-01 21时29分18秒"></p><p>查看其具体内容：<br><img src="截图 2017-10-01 21时31分17秒.jpg" alt="截图 2017-10-01 21时31分17秒"></p><p>它删除了5个 unlink 语句……</p><p>这种修复方式真是简单粗暴啊… 看来我们分析的入口就在这里了。</p><h2 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h2><p>这部分的分析请参考这里：<a href="https://paper.seebug.org/411/" target="_blank" rel="external">https://paper.seebug.org/411/</a> </p><p>(别吐槽——这篇文章分析得很好，省了我很多字 :haha:)</p><h2 id="文件删除能做什么"><a href="#文件删除能做什么" class="headerlink" title="文件删除能做什么"></a>文件删除能做什么</h2><p>通过上面那篇文章，想必大家都能复现文件删除的漏洞了。那么这个漏洞能做什么呢？难道只是单纯的破坏吗？</p><p>我们知道， Discuz X 这类 CMS 软件，都会一个 install 目录，用来处理用户初次安装时的配置和数据库初始化。在安装完成后，会在 data 目录下生成一个 install.lock 文件。如果尝试再次访问 /install 来安装，检测到存在 install.lock，于是提示错误：<br><img src="截图 2017-10-01 22时03分20秒.jpg" alt="截图 2017-10-01 22时03分20秒"></p><p>如果用户没有删除 install 目录，而且我们也可以利用文件删除漏洞的话，我们就可以删掉这个 instal.lock，然后重新安装 Discuz。而重装过程中一般都有写配置文件的步骤，可能会给我们写入一句话的机会。</p><h2 id="分析重装过程"><a href="#分析重装过程" class="headerlink" title="分析重装过程"></a>分析重装过程</h2><p><code>install/index.php</code> 文件控制安装的过程，它的逻辑其实很简单。安装主要分为五个步骤：<br><img src="截图 2017-10-01 22时10分36秒.jpg" alt="截图 2017-10-01 22时10分36秒"></p><ol><li>show_license 显示是否接受协议，同意后跳到 env_check</li><li>env_check 检查目录是否可写和 PHP的相关检测，然后跳到 app_reg</li><li>app_reg 提示是否安装 UCenter Server，POST 到  app_reg，如果 install_ucenter=yes，直接重定向至 db_init，否则显示配置 ucenter 的表单</li><li>db_init 要求填写数据库和网站信息，POST 到 db_init，这时会进行数据库连接和数据表的检查。所以填写的数据库地址等信息要求必须是目标站能够连接的真实的服务器。</li><li>….</li></ol><p>在 db_init 的处理逻辑里，我们看到了想要的：<br><img src="截图 2017-10-01 22时59分56秒.jpg" alt="截图 2017-10-01 22时59分56秒"></p><p>跟进 save_config_file 函数：<br><img src="截图 2017-10-01 23时11分59秒.jpg" alt="截图 2017-10-01 23时11分59秒"></p><p>继续跟进  getvars 函数：<img src="截图 2017-10-01 23时14分11秒.jpg" alt="截图 2017-10-01 23时14分11秒"><br>结果却让人失望，这里的 addcslashes 会转义我们的引号，导致一句话无法逃逸出引号，无法执行。</p><p>但是紧跟着的 install_uc_server 让我很开心：<br><img src="截图 2017-10-01 23时05分25秒.jpg" alt="截图 2017-10-01 23时05分25秒"></p><p>跟进 install_uc_server:<br><img src="截图 2017-10-01 23时19分06秒.jpg" alt="截图 2017-10-01 23时19分06秒"></p><p>发现它没有对传入的参数做任何过滤，传入了 save_uc_config 中:<br><img src="截图 2017-10-01 23时20分58秒.jpg" alt="截图 2017-10-01 23时20分58秒"><br>同样 save_uc_config 也没有做任何处理，直接拼接到配置文件字符串中，然后写入了文件。</p><p>因为 dbhost, dbuser 等参数需要用来连接数据库，所以我们能利用的就只有 tablepre 了，也就是我们指定的数据库前缀。我们构造这样的 tablepre:</p><pre><code>x&apos;);@eval($_POST[pwd]);(&apos;</code></pre><p>实验一下：</p><p><img src="截图 2017-10-01 23时27分59秒.jpg" alt="截图 2017-10-01 23时27分59秒"></p><p>然后查看 config/uc_config.php 文件，发现我们的一句话已经写入了：<br><img src="截图 2017-10-01 23时38分00秒.jpg" alt="截图 2017-10-01 23时38分00秒"></p><p>使用菜刀连接：<br><img src="截图 2017-10-01 23时39分13秒.jpg" alt="截图 2017-10-01 23时39分13秒"> </p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p>最后，附上整个完整利用过程的 EXP：<br><a href="https://gist.github.com/j178/67f4dbd8e87cd012a7caa8752ea06e7b" target="_blank" rel="external">https://gist.github.com/j178/67f4dbd8e87cd012a7caa8752ea06e7b</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;初步分析&quot;&gt;&lt;a href=&quot;#初步分析&quot; class=&quot;headerlink&quot; title=&quot;初步分析&quot;&gt;&lt;/a&gt;初步分析&lt;/h2&gt;&lt;p&gt;先下载官方托管在码云上的 Discuz X 源码：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="Hack" scheme="https://fafe.me/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>Composer 初试</title>
    <link href="https://fafe.me/2017/01/21/php-composer/"/>
    <id>https://fafe.me/2017/01/21/php-composer/</id>
    <published>2017-01-20T16:15:22.000Z</published>
    <updated>2017-01-20T16:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Composer 不是一个包管理器，默认下它不会全局安装任何包，只是在一个项目的某个目录中进行安装，它只是一个<strong>依赖管理</strong>工具。</li><li>Composer 解决的问题是：<ol><li>你有一个项目依赖于若干个库</li><li>其中一些库依赖于其他库</li><li>你声明你依赖的东西</li><li>Composer 会找出哪个版本的包需要安装，并安装他们（将他们下载到你的项目中）<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></li></ol></li></ul><ol><li><p>curl -sS  <a href="https://getcomposer.org/installer" target="_blank" rel="external">https://getcomposer.org/installer</a> | php </p><p>installer是一个PHP脚本，用来下载真正的composer.phar，composer.phar会保存到当前目录中。可以使用 <code>--install-dir</code>指定保存目录。</p></li><li><p>将composer.phar移动到<code>PATH</code>中<br><code>mv composer.phar /usr/local/bin/composer</code><br>这样就可以直接使用<code>composer</code>命令</p></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>composer help <command> 非常有用</li><li><code>composer install</code> 读取当前目录下的<code>composer.lock</code>文件，下载和安装其中提到的库和依赖。如果<code>composer.lock</code>不存在，则查看<code>composer.json</code>文件。</li><li><code>composer update</code> 读取当前目录中的<code>composer.json</code>文件，更新、删除或者安装所有的依赖。</li><li><code>composer init</code></li><li><code>composer require</code> xx 添加xx依赖到<code>composer.json</code>中，并安装他们</li><li>修改composer 全局配置<code>composer config -g repo.packagist composer https://packagist.phpcomposer.com</code></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://docs.phpcomposer.com/00-intro.html" target="_blank" rel="external">Composer中文文档</a></p><p><a href="http://pkg.phpcomposer.com/" target="_blank" rel="external">Packagist/Composer中国全量镜像</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Composer 不是一个包管理器，默认下它不会全局安装任何包，只是在一个项目的某个目录中进行安装，它只是一个&lt;strong&gt;依赖管理&lt;/strong&gt;工具。&lt;/li&gt;
&lt;li&gt;Composer 解决的问题是：&lt;ol&gt;
&lt;li&gt;你有一个项目依赖于若干个库&lt;/li
      
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="PHP" scheme="https://fafe.me/tags/PHP/"/>
    
      <category term="Composer" scheme="https://fafe.me/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>PHP 使用 xdebug 调试之路</title>
    <link href="https://fafe.me/2017/01/21/php-xdebug/"/>
    <id>https://fafe.me/2017/01/21/php-xdebug/</id>
    <published>2017-01-20T16:15:18.000Z</published>
    <updated>2017-01-20T16:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>PHPStorm中调试利用的是xdebug的remote特性，使用的是 <code>DBGp</code>协议，PHPStorm是一个实现了<code>DBGp</code>协议的客户端</li><li>在<code>php.ini</code>中启用<code>xdebug.remote_enable</code>, 配置<code>xdebug.remote_host</code>和<code>xdebug.remote_port</code>, port默认是9000.<br>通过<code>phpinfo()</code>函数的输出，可以在<code>Loaded Configuration File</code>中看到实际加载的<code>php.ini</code>文件是哪一个。</li><li><code>sudo apt install php-xdebug</code>之后，会自动在<code>/etc/php/7.0/apache2/conf.d</code>中创建一个<code>xdebug</code>的配置文件，可以在这个文件中修改关于xdebug的配置，而不用去改通用的<code>php.ini</code>.</li><li>client启动之后会监听 port，等待xdebug发送的请求。</li><li>要使php解释器在运行的时候activate xdebug，有三种方式：<ol><li>从命令行运行php脚本时，设置环境变量<code>export XDEBUG_CONFIG=&quot;idekey=session_name&quot;</code>, 同样也可以在<code>XDEBUG_CONFIG</code>环境变量中设置<code>remote_host</code>,<code>remote_port</code>等属性。</li><li>从一个浏览器中启动debugger，需要传递一个<code>XDEBUG_SESSION_START=session_name</code>参数，这个参数可以是<code>GET</code>，<code>POST</code>或者<code>Cookie</code>。可以使用一些浏览器的插件自动传递这个参数。</li></ol></li><li>只要<code>xdebug.remtoe_enable</code>开启了，PHPStorm打开了 Listening for PHP Debug，也就是服务器和客户端都准备好了，然后浏览器发送请求的时候包含一个<code>XDEBUG_SESSION_START</code>参数（？文档中写的是XDEBUG_SESSION_START,而实际上<code>bookmark</code>和插件中设置的cookie都是<code>XDEBUG_SESSION</code>），就可以愉快地调试了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;PHPStorm中调试利用的是xdebug的remote特性，使用的是 &lt;code&gt;DBGp&lt;/code&gt;协议，PHPStorm是一个实现了&lt;code&gt;DBGp&lt;/code&gt;协议的客户端&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;php.ini&lt;/code&gt;中启用&lt;cod
      
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="PHP" scheme="https://fafe.me/tags/PHP/"/>
    
      <category term="xdebug" scheme="https://fafe.me/tags/xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Python 图片处理库: Pillow</title>
    <link href="https://fafe.me/2017/01/21/python-pillow/"/>
    <id>https://fafe.me/2017/01/21/python-pillow/</id>
    <published>2017-01-20T16:15:07.000Z</published>
    <updated>2017-01-20T16:22:58.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Image.open()<br>im.mode, im.size, im.format</li><li>Image.save()</li><li>Image.show()<br>性能很慢, 仅作调试用.</li><li>Image.convert()<br>比较常用的函数</li><li>Image.crop()</li><li>Image.paste()</li><li>Image.split()<br>将图像分为不同的 band</li><li>Image.getpixel()</li><li>Image.putpixel()<br>很慢</li><li>Image.point()<br>可以接受一个 lookup table, 或者一个函数, 函数接受一个参数, 这个参数可以看做像素点的颜色, 返回值为像素点的新颜色</li><li>Image.thumbnail()<br>生成缩略图, 会直接修改原图, 如果要保留原图需要先用 <code>Image.copy()</code></li><li>Image.getbbox()<br>这个函数好像很好用的样子, 待会儿再尝试</li><li>Image.getcolors(maxcolors=256)<br>获取图片中用到的所有颜色, 返回 [ (count, color),… ]<br>如果是 RGB 等格式, color 也是一个 <code>tuple</code>, 所以不同的颜色会有很多, 需要传入较大的 maxcolors, 否则会返回 <code>None</code></li><li>Image.histogram()<br>获取图片的直方图, 返回一个<code>list</code>, 如果是灰度图像, 则 list 大小为256, 每个元素表示0-255各个灰度的像素点的个数. 如果是 RGB 图像, 则 list 大小为 256*3.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Image.open()&lt;br&gt;im.mode, im.size, im.format&lt;/li&gt;
&lt;li&gt;Image.save()&lt;/li&gt;
&lt;li&gt;Image.show()&lt;br&gt;性能很慢, 仅作调试用.&lt;/li&gt;
&lt;li&gt;Image.convert()&lt;br
      
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://fafe.me/tags/Python/"/>
    
      <category term="Pillow" scheme="https://fafe.me/tags/Pillow/"/>
    
  </entry>
  
  <entry>
    <title>跨域相关</title>
    <link href="https://fafe.me/2017/01/20/cross-domain/"/>
    <id>https://fafe.me/2017/01/20/cross-domain/</id>
    <published>2017-01-20T15:55:43.000Z</published>
    <updated>2017-01-20T16:21:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>origin = 协议 + 域名 + 端口号</p><p>同源策略的限制：</p><ol><li>Cookie, LocalStorage 和 IndexDB 无法读取</li><li>DOM 无法获得</li><li>AJAX 无法发送</li></ol><p>可跨域的标签 script，img，iframe, link等</p><p>JSONP 实质是一种自己发起的XSS</p><p>无法在 https 页面发起对非https的请求，会出现 Mixed content 错误</p><h2 id="CORS方案"><a href="#CORS方案" class="headerlink" title="CORS方案"></a>CORS方案</h2><p>发起跨域请求时，浏览器会自动设置<code>Origin</code>首部，无法手动改变<br>在服务端的响应中设置<code>Access-Control-Allow-Origin</code>首部<br>但是这个首部不支持多个 host，所以如果需要支持多个 domain，需要动态地生成这个首部。比如说：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt; ?php</div><div class="line">$allowedOrigins = <span class="keyword">array</span>(<span class="string">"http://example.com"</span>, <span class="string">"http://localhost:63342"</span>);</div><div class="line">$headers = getallheaders();</div><div class="line"><span class="keyword">if</span> ($headers[<span class="string">"Origin"</span>] &amp;&amp; in_array($headers[<span class="string">"Origin"</span>], $allowedOrigins)) &#123;</div><div class="line">    header(<span class="string">"Access-Control-Allow-Origin: "</span> . $headers[<span class="string">"Origin"</span>]);</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h3 id="是否发送凭证"><a href="#是否发送凭证" class="headerlink" title="是否发送凭证"></a>是否发送凭证</h3><p>客户端：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.withCredentials = <span class="literal">true</span>;</div></pre></td></tr></table></figure><p>服务端添加 <code>Access-Control-Allow-Credentials : true</code>首部，如果服务器端没有返回这个首部，即使当前domain是允许的，客户端也得不到响应。会有类似 <em>XMLHttpRequest cannot load <a href="http://example.com/index.php" target="_blank" rel="external">http://example.com/index.php</a>. Credentials flag is ‘true’, but the ‘Access-Control-Allow-Credentials’ header is ”. It must be ‘true’ to allow credentials. Origin ‘<a href="http://localhost:63342‘" target="_blank" rel="external">http://localhost:63342‘</a> is therefore not allowed access.</em> 的提示。</p><p>当开启 withCredential 属性时，服务器返回的<code>Access-Control-Allow-Origin</code>不允许为<code>*</code></p><h3 id="Preflight"><a href="#Preflight" class="headerlink" title="Preflight"></a>Preflight</h3><p>当跨域请求不是简单请求时，浏览器会先发送一个预检请求(preflight)</p><p>浏览器先通过OPTIONS方法询问 request的方法和首部是否支持:</p><p><code>Access-Control-Request-Method</code></p><p><code>Access-Control-Request-Headers</code></p><p>如果服务端允许跨域请求，则返回几个特殊的首部：</p><p><code>Access-Control-Allow-Methods</code>:必需。返回所有支持的方法，而不单是浏览器请求的那个方法，这是为了避免多次预检请求。</p><p><code>Access-Control-Allow-Headers</code>：如果请求中有<code>Access-Control-Request-Headers</code>，则必需。返回所有支持的首部信息。</p><p><code>Access-Control-Allow-Credentials</code></p><p><code>Access-Control-Allow-Max-Age</code>:可选，指定本次预检的有效期，单位为秒。</p><p>一旦服务器通过了预检，以后每次浏览器正常的CORS请求都跟简单请求一样，包含一个<code>Origin</code>首部，服务器的相应也会有一个<code>Access-Control-Allow-Origin</code>。</p><h3 id="crossorigin属性"><a href="#crossorigin属性" class="headerlink" title="crossorigin属性"></a><code>crossorigin</code>属性</h3><p>通常 <code>&lt;link&gt; &lt;script&gt; &lt;img&gt;</code>这些本身就可以跨域的标签，在请求时不会发送<code>Origin</code>首部，所以我们也无法使用 JS 获取他们的内容(会报错)。如果为这些标签设置<code>crossorigin</code>属性，则请求时就会使用<code>CORS</code>请求，并且设置了<code>Origin</code>首部。</p><p><code>crossorigin</code>有两个可能的值：<code>anonymouse</code>：不会发送credentials，<code>use-credentials</code>：发送credentials</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">浏览器同源政策及其规避方法</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;p&gt;origin = 协议 + 域名 + 端口号&lt;/p&gt;
&lt;p&gt;同源策略的限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cookie, Lo
      
    
    </summary>
    
      <category term="前端" scheme="https://fafe.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="同源策略" scheme="https://fafe.me/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
      <category term="跨域" scheme="https://fafe.me/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow 初试</title>
    <link href="https://fafe.me/2017/01/19/tensorflow/"/>
    <id>https://fafe.me/2017/01/19/tensorflow/</id>
    <published>2017-01-19T15:55:43.000Z</published>
    <updated>2017-01-20T16:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p><code>pip install tensorflow</code></p></li><li><p>如果安装GPU版本的，需要安装 Cuda Toolkit 8.0 和 cuDNN v5.1<br><code>pip install tensorflow-gpu</code><br>并且设置环境变量 <code>LD_LIBRARY_PATH</code>和<code>CUDA_HOME</code>。</p></li><li><p>运行 demo model</p><p><code>python -m tensorflow.models.image.mnist.convolutional</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pip install tensorflow&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果安装GPU版
      
    
    </summary>
    
      <category term="机器学习" scheme="https://fafe.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="TensorFlow" scheme="https://fafe.me/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>127.0.1.1是什么？</title>
    <link href="https://fafe.me/2017/01/19/127.0.0.1/"/>
    <id>https://fafe.me/2017/01/19/127.0.0.1/</id>
    <published>2017-01-19T10:55:43.000Z</published>
    <updated>2017-01-20T16:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Some software (e.g., GNOME) expects the system hostname to be resolvable to an IP address with a canonical fully qualified domain name. This is really improper because system hostnames and domain names are two very different things; but there you have it. In order to support that software, it is necessary to ensure that the system hostname can be resolved. Most often this is done by putting a line in <code>/etc/hosts</code> containing some IP address and the system hostname. If your system has a permanent IP address then use that; otherwise use the address 127.0.1.1.</p><p><code>/etc/hosts</code></p><p><code>/etc/hostname</code></p><p>The system hostname should always be resolvable even when the network is down. Basically, some applications still try to resolve a host via 127.0.1.1 so in order to accommodate, it is kept by default on current debian-type distributions.</p><p>The general rule of thumb is: If you don’t have a permanent IP address for your host, use 127.0.1.1.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Some software (e.g., GNOME) expects the system hostname to be resolvable to an IP address with a canonical fully qualified domain name. T
      
    
    </summary>
    
      <category term="Misc" scheme="https://fafe.me/categories/Misc/"/>
    
    
      <category term="hostname" scheme="https://fafe.me/tags/hostname/"/>
    
  </entry>
  
  <entry>
    <title>Apache 配置学习</title>
    <link href="https://fafe.me/2017/01/18/apache-config/"/>
    <id>https://fafe.me/2017/01/18/apache-config/</id>
    <published>2017-01-18T15:55:43.000Z</published>
    <updated>2017-01-20T16:20:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><ul><li>配置文件<code>/etc/apach2/apache2.conf</code>以及<code>/etc/apache2/conf-enabled</code></li><li><code>DirectoryIndex index.html index.php</code> 优先级从左到右降低</li><li>包含外部配置文件 <code>Include xxx</code></li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>apachectl</code>脚本，从<code>/etc/apache2/envavars</code>中读取并设置一些环境变量</p><h2 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h2><p>基于正则表达式的规则，动态修改 incoming URl requests。</p><h2 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h2><p>用同一个 Apache 服务器上搭建多个服务，根据用户请求中不同的 Host首部（或其他条件） 将请求转给不同的<code>VirtualHost</code>来处理。</p><h3 id="Name-based-vs-IP-based-Virtual-Hosts"><a href="#Name-based-vs-IP-based-Virtual-Hosts" class="headerlink" title="Name-based vs IP-based Virtual Hosts"></a>Name-based vs IP-based Virtual Hosts</h3><p>基于IP的虚拟主机，要求服务器有多个IP，Apache根据用户请求的IP来转发到相应的主机中<br>基于名字的虚拟主机，要求客户端在HTTP首部中包含主机的名字，这样多个主机就可以共享同一个IP。<br>基于名字(hostname)的虚拟主机，通常只需要将多个域名解析到同一个IP即可。<br>比如说，login.a.com和logout.a.com只想相同的IP，也使用相同的端口（即后台的web服务器是同一个），但是后台的web服务器却可以根据请求中的Host首部不同，为他们提供不同的服务。</p><h3 id="服务器如何选择合适的-name-based-virtual-host"><a href="#服务器如何选择合适的-name-based-virtual-host" class="headerlink" title="服务器如何选择合适的 name-based virtual host?"></a>服务器如何选择合适的 name-based virtual host?</h3><p>先进行 IP-based的选择，也就是先根据请求的IP选择出为此IP服务的Virtual Host，然后再从中找出最符合的name-based virtual host。</p><p>先根据IP和端口选出一组最符合的hosts，然后根据<code>ServerName</code>和<code>ServerAlias</code>作比较。如果没有符合的ServerName和ServerAlias，则选择列出的第一个。</p><p>省略ServerName则默认使用fully qualified domain name。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://httpd.apache.org/docs/2.4/vhosts/name-based.html" target="_blank" rel="external"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;headerlink&quot; title=&quot;基本&quot;&gt;&lt;/a&gt;基本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;配置文件&lt;code&gt;/etc/apach2/apache2.conf&lt;/code&gt;以及&lt;code&gt;/etc/apache2/co
      
    
    </summary>
    
      <category term="后端" scheme="https://fafe.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Apache" scheme="https://fafe.me/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>PHP 基础回顾</title>
    <link href="https://fafe.me/2017/01/18/php-beginning/"/>
    <id>https://fafe.me/2017/01/18/php-beginning/</id>
    <published>2017-01-18T13:00:43.000Z</published>
    <updated>2017-01-20T16:20:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="include-require"><a href="#include-require" class="headerlink" title="include/require"></a>include/require</h3><p>如果没有提供路径，则会查找<code>include_path</code>，如果没有找到，则会查找当前脚本所在目录和当前工作目录。如果均失败的话，include 会产生一个 warnning，require会产生一个 fatal error.</p><p>当一个文件被 <code>included</code>时，被包含文件中的代码继承了<code>include</code>所在行的变量作用域。任何在<code>include</code>处可见的变量，对于被包含的代码也可见（相当于将被包含的代码复制并替换<code>include</code>命令。）但是，被包含文件中定义的函数和类都拥有全局作用域。</p><p>在解析被包含的文件时，解析器会切换为 HTML模式，所以任何没有包含在 php tag中的文本都会当做HTML处理，也就是会被原样 echo 给客户端。</p><p>include失败会返回FALSE，并产生一个warning。如果include成功，并且被包含文件中没有<code>return</code>语句，include会返回<code>1</code>。 如果被包含文件中有return语句，那么执行到return语句时，会停止对被包含文件的处理，并返回return提供的值，就像调用一个普通的函数一样。</p><p>如果被包含文件中定义了函数，并且被包含了两次，则会造成 fatal error，因为函数已经被声明过了。最好使用 include_once。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><code>sudo apt-add-repository ppa:ondrej/php5</code></li><li><code>php-xxx</code>都是PHP的扩展包，比如<code>php-gd</code>，<code>php-mysql</code>，<code>php-xdebug</code>需要手动安装</li><li>Apache 通过 <code>libapache2-mod-php7.1</code>模块与PHP互动，配置文件为<code>/etc/apache2/mod-enabled/php7.0/</code>中</li><li><code>/usr/bin/php</code>也只是一个<code>alternative</code>，可以使用update-alternative改变当前<code>php</code>命令使用的版本</li></ul><p>安装过程中的处理：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">Setting up php7.1-common (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/calendar.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/ctype.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/exif.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/fileinfo.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/ftp.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/gettext.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/iconv.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/pdo.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/phar.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/posix.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/shmop.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/sockets.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/sysvmsg.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/sysvsem.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/sysvshm.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/tokenizer.ini with new version</div><div class="line">Setting up php7.1-json (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/json.ini with new version</div><div class="line">Setting up php7.1-opcache (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/opcache.ini with new version</div><div class="line">Setting up php7.1-readline (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/readline.ini with new version</div><div class="line">Setting up php7.1-cli (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line">update-alternatives: using /usr/bin/php7.1 to provide /usr/bin/php (php) <span class="keyword">in</span> auto mode</div><div class="line">update-alternatives: using /usr/bin/phar7.1 to provide /usr/bin/phar (phar) <span class="keyword">in</span> auto mode</div><div class="line">update-alternatives: using /usr/bin/phar.phar7.1 to provide /usr/bin/phar.phar (phar.phar) <span class="keyword">in</span> auto mode</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/cli/php.ini with new version</div><div class="line">Setting up libapache2-mod-php7.1 (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/apache2/php.ini with new version</div><div class="line">libapache2-mod-php7.1: php7.0 module already enabled, not enabling PHP 7.1</div><div class="line">Setting up libapache2-mod-php (1:7.1+49+deb.sury.org~xenial+4) ...</div><div class="line">Setting up php7.0-common (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.0-mcrypt (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.0-mbstring (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.0-xml (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.0-readline (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.0-opcache (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.0-mysql (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.0-json (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up libwebp5:amd64 (0.4.4-1+deb.sury.org~xenial+1) ...</div><div class="line">Setting up libgd3:amd64 (2.2.3-3+deb.sury.org~xenial+0) ...</div><div class="line">Setting up php7.0-gd (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.0-curl (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.0-cli (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Replacing config file /etc/php/7.0/cli/php.ini with new version</div><div class="line">Setting up libapache2-mod-php7.0 (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Installing new version of config file /etc/apache2/mods-available/php7.0.load ...</div><div class="line">libapache2-mod-php7.0: not switching MPM - already enabled</div><div class="line">Setting up php7.0 (7.0.14-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up libjbig0:amd64 (2.1-3.1+deb.sury.org~xenial+1) ...</div><div class="line">Setting up libpcre16-3:amd64 (2:8.39-1+deb.sury.org~xenial+1) ...</div><div class="line">Setting up libsodium18:amd64 (1.0.10-1+deb.sury.org~xenial+1) ...</div><div class="line">Setting up libssl-doc (1.0.2j-1+deb.sury.org~xenial+1) ...</div><div class="line">Setting up libssl-dev:amd64 (1.0.2j-1+deb.sury.org~xenial+1) ...</div><div class="line">Setting up libwebpmux1:amd64 (0.4.4-1+deb.sury.org~xenial+1) ...</div><div class="line">Setting up libzmq5:amd64 (4.2.0-1+deb.sury.org~xenial+1) ...</div><div class="line">Setting up openssl (1.0.2j-1+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.1-curl (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/curl.ini with new version</div><div class="line">Setting up php-curl (1:7.1+49+deb.sury.org~xenial+4) ...</div><div class="line">Setting up php7.1-gd (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/gd.ini with new version</div><div class="line">Setting up php-gd (1:7.1+49+deb.sury.org~xenial+4) ...</div><div class="line">Setting up php7.1-xml (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/dom.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/simplexml.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/wddx.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/xml.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/xmlreader.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/xmlwriter.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/xsl.ini with new version</div><div class="line">Setting up php-xml (1:7.1+49+deb.sury.org~xenial+4) ...</div><div class="line">Setting up php-pear (1:1.10.1+submodules+notgz-8+donate.sury.org~xenial+2) ...</div><div class="line">Setting up php-gettext (1.0.11-2+deb.sury.org~xenial+1) ...</div><div class="line">Setting up php7.1-mbstring (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/mbstring.ini with new version</div><div class="line">Setting up php-mbstring (1:7.1+49+deb.sury.org~xenial+4) ...</div><div class="line">Setting up php7.1-mcrypt (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/mcrypt.ini with new version</div><div class="line">Setting up php-mcrypt (1:7.1+49+deb.sury.org~xenial+4) ...</div><div class="line">Setting up php7.1-mysql (7.1.0-5+deb.sury.org~xenial+1) ...</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/mysqlnd.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/mysqli.ini with new version</div><div class="line"></div><div class="line">Creating config file /etc/php/7.1/mods-available/pdo_mysql.ini with new version</div><div class="line">Setting up php-mysql (1:7.1+49+deb.sury.org~xenial+4) ...</div><div class="line">Setting up php-xdebug (2.5.0-1+deb.sury.org~xenial+1) ...</div><div class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.23-0ubuntu5) ...</div><div class="line">Processing triggers <span class="keyword">for</span> libapache2-mod-php7.1 (7.1.0-5+deb.sury.org~xenial+1) ...</div></pre></td></tr></table></figure><ul><li>问题，现在通过<code>a2enmod php7.1</code>启用了PHP7.1，那么对于PHP的请求，会交给PHP7.0呢？还是PHP7.1呢？ =》 默认的还是PHP7.0，需要自己手动 <code>a2dismod php7.0</code>才行</li><li>php-pear是什么？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;include-require&quot;&gt;&lt;a href=&quot;#include-require&quot; class=&quot;headerlink&quot; title=&quot;include/require&quot;&gt;&lt;/a&gt;include/require&lt;/h3&gt;&lt;p&gt;如果没有提供路径，则会查找&lt;code
      
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="PHP" scheme="https://fafe.me/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Posix Thread 基础</title>
    <link href="https://fafe.me/2017/01/01/posix-thread/"/>
    <id>https://fafe.me/2017/01/01/posix-thread/</id>
    <published>2016-12-31T16:14:03.000Z</published>
    <updated>2017-01-20T16:19:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p>一个线程包含在进程中表示一个 execution context 的必要信息，包括 <em>thread ID</em>, a set of register values, a stack, a scheduling priority and policy, a signal mask, an <code>errno</code> variable, and thread-specific data.</p><p>进程中的所有东西都是线程间共享的，包括 text of the executable program, the programs’s global and heap memory, the stacks, and the file descriptors. <a id="more"></a></p><h3 id="线程-ID"><a href="#线程-ID" class="headerlink" title="线程 ID"></a>线程 ID</h3><p>每个进程都有一个 <em>系统内</em> 唯一的ID，由<code>pid_t</code>类型表示，类似的，每个线程都一个 <em>进程内</em> 唯一的ID, 由<code>pthread_t</code>类型表示。<code>pthread_t</code>的具体类型由实现决定，可能是整数、指针或者结构体，所以不能之间判断两个<code>pthread_t</code>是否相等，需要用<code>pthread_equal</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;</div><div class="line">truetruetruetrueReturns nonzeron <span class="keyword">if</span> equal, <span class="number">0</span> otherwise.</div></pre></td></tr></table></figure><p>一个线程可以通过<code>pthread_self</code>函数获取自己的ID:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pthread_t</span> pthread_t_self(<span class="keyword">void</span>);</div></pre></td></tr></table></figure><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tidp,</span></span></div><div class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></div><div class="line">                  void *(*start_routine)(void *),</div><div class="line">                   <span class="keyword">void</span> *arg);</div><div class="line">truetruetruetruetruetruetruetruetrueReturns: <span class="number">0</span> <span class="keyword">if</span> OK, error number on failure</div></pre></td></tr></table></figure><p><em>tidp</em>被设置为新创建的线程的ID，<em>attr</em>参数用来控制线程的属性，这里用<code>NULL</code>表示使用默认的属性。</p><p>新创建的线程从 <em>start_routine</em>函数处开始执行，这个函数接受一个无类型的指针 <code>void* arg</code>.</p><blockquote><p>无类型指针（通用指针），只记录了内存的起始地址，指向的目标的大小并不知道，所以不能dereference，只能将它强制转换为其他类型的指针，此时目标的大小已经知道，所以可以dereference，然后对内存做各种操作。</p></blockquote><p>当线程创建完成后，并没有保证是调用<code>pthread_create</code>的线程先执行还是新创建的线程先执行。所以如果<code>pthread_create</code>的第一个参数是一个全局变量，那么当新线程开始执行时，主线程可能还有从<code>pthread_create</code>中返回，也就是说全局变量可能还没有赋值，所以新线程访问到的全局变量可能是未初始化的变量。</p><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>任何一个线程调用<code>exit</code>, <code>_exit</code> 或 <code>Exit</code>, 都会导致整个进程终止。当默认行为是终止进程时，比如一个信号发给一个线程，也会终止整个进程。</p><p>一个线程可以以三种方式终止而不用终止整个进程：</p><ol><li>线程routine执行到return语句，return值会作为线程的exit code</li><li>线程被同一个进程中的其他线程 cancel</li><li>线程自己调用pthread_exit，其参数作为 exit code</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span></div></pre></td></tr></table></figure><p>exit code 可以被其他调用 <code>pthread_join</code>的线程获取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> ** rval_ptr)</span></span>;</div><div class="line">truetruetruetruetruetruetruetrueReturn: <span class="number">0</span> <span class="keyword">if</span> OK, error number on failure</div></pre></td></tr></table></figure><p>调用<code>pthread_join</code>的线程会阻塞直到其等待的线程退出。如果被等待的线程正常退出(return)，<em>rval_ptr</em>将是 return code。如果被等待的线程是被 canceled，<em>rval_ptr</em>会被设为 <code>PTHREAD_CANCELED</code>(-1).</p><blockquote><p> 线程可以cancel自己吗？</p></blockquote><p>通过调用<code>pthread_join</code>，被等待的线程会被置为 <em>detached state</em>, 所以其资源？。如果被等待的线程已经是 <em>detached state</em>, 那么<code>pthread_join</code>会失败，返回<code>EINVAL</code>。 </p><p>一个线程可以调用<code>pthread_cancel</code>来请求同一个进程中的另一个线程 be canceled：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div><div class="line">truetruetruetruetruetruetruetruetrueReturns: <span class="number">0</span> <span class="keyword">if</span> OK, error number on failure</div></pre></td></tr></table></figure><p>默认情况下，<code>pthread_cancel</code>会导致 <code>tid</code>指定的线程就像自己以参数<code>PTHREAD_CANCELED</code>调用<code>pthread_exit</code>一样。但是，一个线程可以选择忽略或者控制自己如果 cancel。<code>pthread_cancel</code>函数并不等待线程<code>tid</code>退出，它仅仅发出这个cancel请求。</p><p>线程退出时做清理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void pthread_cleanup_push(void (*routine)(void *),void *arg);</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</div></pre></td></tr></table></figure><p>默认情况下，线程的退出状态会被一直保留，直到为它调用<code>pthread_join</code> ，而一个 <em>detached</em> 线程的储存空间可能会被立即回收。如果一个线程已经<em>detached</em>, 那么我们无法为其调用<code>pthread_join</code>，为一个<em>detached</em> thread 调用 <code>pthread_join</code>会导致未定义行为。</p><p>通过<code>pthread_detach</code>，我们可以将一个线程 <em>detach</em>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_deatch</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div></pre></td></tr></table></figure><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>如果所有的操作都只需要一个 memory cycle，那么就不会有不一致的问题。如果修改变量的操作是原子的，那么也不会有竞争的问题。那么也不需要同步。但实际情况不是这样。</p><ol><li><p>Mutex</p><p>一个 <em>mutex</em> 是一个互斥锁，当我们访问一个共享资源时设置它，当访问完成时释放它。当 mutex is set, 所有其他试图set它的线程都会被block直到有人release它。当它被释放时，所有等待它的线程都变为可运行的，第一个运行的 will be able to set the lock，其他的线程继续等到它available again。这样，每次只能有一个线程 proceed。</p><p>这种<em>互斥</em>只有在所有线程都遵守相同的访问规则时才有效，比如说所有人在访问变量之前都必须获取锁。如果允许一个线程在访问前不获取锁，那么即使其他线程正在持有锁，它也依然可以访问到变量，这可能造成不一致。</p><p>一个互斥变量由 <code>pthread_mutex_t</code>表示，使用前必须初始化。要么初始化为常量<code>PTHREAD_MUTEX_INITIALIZER</code> (只用于静态分配的mutex)，要么使用<code>pthreat_mutex_init</code> (动态分配的mutex，free mutex前必须调用<code>pthread_mutex_destroy</code>):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex,</span></span></div><div class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure><p>要锁定一个 mutex，我们调用 <code>pthread_mutex_lock</code>，如果这个 mutex 已经被锁定，那么调用的线程被阻塞，直到 mutex 被解锁。解锁一个 mutex 我们调用 <code>pthread_mutex_unlock</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mtuex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure><p>如果线程不想被阻塞，它可以调用 <code>pthread_mutex_trylock</code>，如果 mutex 没有被锁，那么调用 <code>pthread_mutex_trylock</code>会锁定这个 mutex，返回0，否则调用会失败，返回<code>EBUSY</code>，不阻塞，且不会锁定这个mutex。</p></li></ol><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>一个线程试图锁定一个 mutex 两次会造成死锁。</p><p>如果程序中使用了多个 mutex， 当一个线程持有一个 mutex 的锁并且试图锁定第二个 mutex，同时另外一个线程持有第二个 mutex的锁并且试图锁定一个 mutex 时，就会造成死锁。</p><p>小心的控制加锁的顺序可以避免死锁。</p><p>如果一个线程持有一个锁，并且调用<code>pthread_mutex_trylock</code>成功，那么线程可以继续，否则线程就释放自己持有的所有的锁，clean up, try again later。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>APUE.3e</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程概念&quot;&gt;&lt;a href=&quot;#线程概念&quot; class=&quot;headerlink&quot; title=&quot;线程概念&quot;&gt;&lt;/a&gt;线程概念&lt;/h3&gt;&lt;p&gt;一个线程包含在进程中表示一个 execution context 的必要信息，包括 &lt;em&gt;thread ID&lt;/em&gt;, a set of register values, a stack, a scheduling priority and policy, a signal mask, an &lt;code&gt;errno&lt;/code&gt; variable, and thread-specific data.&lt;/p&gt;
&lt;p&gt;进程中的所有东西都是线程间共享的，包括 text of the executable program, the programs’s global and heap memory, the stacks, and the file descriptors.
    
    </summary>
    
    
      <category term="Linux" scheme="https://fafe.me/tags/Linux/"/>
    
      <category term="Thread" scheme="https://fafe.me/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Python logging 基础</title>
    <link href="https://fafe.me/2016/12/30/python-logging/"/>
    <id>https://fafe.me/2016/12/30/python-logging/</id>
    <published>2016-12-30T04:23:23.000Z</published>
    <updated>2017-01-20T16:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line"></div><div class="line">logger=logging.getLogger(__name__)</div><div class="line">logger.setLevel(logging.INFO)</div><div class="line"></div><div class="line"><span class="comment"># 添加handler</span></div><div class="line">handler=logging.FileHandler(<span class="string">'hello.log'</span>)</div><div class="line">handler.setLevel(logging.INFO)</div><div class="line"><span class="comment"># handler可以有多个，所以用add</span></div><div class="line">logger.addHandler(handler)</div><div class="line"></div><div class="line"><span class="comment"># 设置格式</span></div><div class="line">formatter=logging.Formatter(<span class="string">'[%(asctime)s] [%(levelname)s] %(message)s'</span>, <span class="string">'%H:%M:%S'</span>)</div><div class="line"><span class="comment"># formatter只能有一个</span></div><div class="line">logger.setFormatter(formatter)</div></pre></td></tr></table></figure></p><p>对于库来说，通常使用 <em>__name__</em> 来获取 Logger对象，然后只添加一个<code>NullHandler</code>，表示默认不会输出任何log: <a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置默认日志处理方式，避免“未找到处理方法”的警告。</span></div><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="keyword">try</span>:  <span class="comment"># Python 2.7+</span></div><div class="line">    <span class="keyword">from</span> logging <span class="keyword">import</span> NullHandler</div><div class="line"><span class="keyword">except</span> ImportError:</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NullHandler</span><span class="params">(logging.Handler)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">emit</span><span class="params">(self, record)</span>:</span></div><div class="line">            <span class="keyword">pass</span></div><div class="line"></div><div class="line">logging.getLogger(__name__).addHandler(NullHandler())</div></pre></td></tr></table></figure><p>什么情况下会抛出‘未找到处理方法’的异常呢？</p><p>如果没有添加NullHandler()，即没有配置任何Handler，日志会被发给root，然后默认下root会怎么处理呢？试验的结果是：向终端输出了异常的信息。</p><p>如果添加了NullHandler()，则没有任何输出。这是因为添加了NullHandler()，found不为0，不会去使用保底的手段，又因为root本身的handlers也为空，所以就只调用了NullHandler的handle，于是就什么也输出了。</p><p>如果没添加NullHandler()，则会使用保底的lastResort手段，所以会向stderr写入log。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>Handler send the log records (created by loggers) to the appropriate destination</li><li>Fliters provide a finer grained facility for determining which log recoreds to output</li><li>Formatters specify the layout of log records in the final output</li></ol><h2 id="Logger-对象"><a href="#Logger-对象" class="headerlink" title="Logger 对象"></a>Logger 对象</h2><p>Logger不会直接初始化，只能通过<code>logging.getLogger(name)</code>获取，多次以同样的<code>name</code>调用返回的是同一个对象。</p><p><code>name</code>以<code>.</code>分隔，表示级别。如<code>foo.bar.baz</code>，<code>foo.bar</code>,<code>foo.bar.baz</code>,<code>foo.bam</code>都是<code>foo</code>的下一级。logger的分级与Python的模块分级类型，所以推荐的<code>name</code>值通常是<code>_name__</code>.</p><ol><li><p><code>Logger.propagate</code><br>如果为True，events logged to this logger除了发给handlers attatched to this logger外，还会传递给这个logger的父辈。默认为True。<br>如果只对root logger设置handler，这样所有后代logger的事件都会发送给这个handler处理，这样可以避免同一个日志被输出多次。</p></li><li><p><code>Logger.setLevel(lvl)</code><br>Set the threshold for this logger to <em>lvl</em>. 小于 <em>lvl</em> 的消息会被忽略。<br>root logger的默认level为WARNNING，其他logger默认为NOTSET.</p></li><li><p><code>Logger.isEnabledFor(lvl)</code><br>测试 <em>lvl</em> 级别的消息是否能被此logger处理</p></li><li><p><code>Logger.getEffectiveLevel</code><br>如果当前logger的level不为<code>NOTSET</code>, 则返回此level。 否则向上遍历，直到找到一个level不为<code>NOTSET</code>的logger.</p></li><li><p><code>Logger.getChild(suffix)</code></p></li><li><p><code>Logger.debug(msg, *args, **kwargs)</code><br>msg是一个消息格式化字符串，args是将要格式化的参数，即<code>msg % args</code><br>有三个关键字参数: <code>exc_info</code>, <code>stack_info</code>, <code>extra</code><br>extra用来填充<code>LogRecord.__dict__</code>，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FORMAT = <span class="string">'%(asctime)-15s %(clientip)s %(user)-8s %(message)s'</span></div><div class="line">logging.basicConfig(format=FORMAT)</div><div class="line">d = &#123;<span class="string">'clientip'</span>: <span class="string">'192.168.0.1'</span>, <span class="string">'user'</span>: <span class="string">'fbloggs'</span>&#125;</div><div class="line">logger = logging.getLogger(<span class="string">'tcpserver'</span>)</div><div class="line">logger.warning(<span class="string">'Protocol problem: %s'</span>, <span class="string">'connection reset'</span>, extra=d)</div><div class="line">//输出</div><div class="line">//<span class="number">2006</span><span class="number">-02</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">20</span>:<span class="number">02</span>,<span class="number">165</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> fbloggs  Protocol problem: connection reset</div></pre></td></tr></table></figure></li><li><p><code>Logger.hasHandlers</code><br>检查当前logger是否配置了任何handler，通过循环遍历其所有parent的handlers得到结果，如果有任何一个parent的handlers数组不为空，则返回True.</p></li><li><p>​</p></li></ol><h2 id="LogRecord"><a href="#LogRecord" class="headerlink" title="LogRecord"></a>LogRecord</h2><p>Logger对象产生 LogRecord对象，传递给 <em>Handler</em>.   Logger和Handler都可以使用 <em>logging level</em> 和 <em>Filter</em>来决定他们感兴趣的 <em>LogRecord</em>对象。当需要output LogRecord时，一个 Handler使用一个 <em>Formatter</em>来格式化字符串并把它发送到 I/O流中。</p><p>每个Logger记录一组 output Handlers，默认情况下，所有的 Logger也会将他们的输出发给他们的 ancestor Loggers。</p><h2 id="Logging-级别"><a href="#Logging-级别" class="headerlink" title="Logging 级别"></a>Logging 级别</h2><table><thead><tr><th>Level</th><th>数值</th></tr></thead><tbody><tr><td>CRITICAL</td><td>50</td></tr><tr><td>ERROR</td><td>40</td></tr><tr><td>WARNNING</td><td>30</td></tr><tr><td>INFO</td><td>20</td></tr><tr><td>DEBUG</td><td>10</td></tr><tr><td>NOTSET</td><td>0</td></tr></tbody></table><h2 id="模块级函数"><a href="#模块级函数" class="headerlink" title="模块级函数"></a>模块级函数</h2><ol><li><p><code>logging.getLogger(name=None)</code><br>如果name=None，则返回root logger。<br>因为相同名字返回的是同一个对象，所以logger不应该在程序的不同部分之间传递。</p></li><li><p><code>logging.debug(msg, *args, **kwargs)</code><br>Logs a message with level <code>DEBUG</code> on the root logger.</p></li><li><p><code>logging.disable(lvl)</code></p></li><li><p><code>logging.basicConfig(**kwargs)</code><br>创建一个<code>StreamHandler</code>,使用默认的<code>Formatter</code>，并把其加入到root logger中。模块级的<code>debug()</code>等函数都会自动调用<code>basicConfig()</code>，如果没有为root logger设置任何handler的话。</p></li></ol><h2 id="最简单的使用："><a href="#最简单的使用：" class="headerlink" title="最简单的使用："></a>最简单的使用：</h2><ol><li><p>在主线程的模块中，在其他线程启动之前调用<code>logging.basicConfig</code>为root logger设置基本的level和格式</p></li><li><p>其他模块中直接<code>import logging</code>，然后使用模块级的<code>logging.debug</code>即可。</p></li></ol><h2 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h2><ol><li>Logger类有一个root属性，指向的是RootLogger(WARNING).<br>RootLogger是Logger的一个子类，且Logger.name默认初始化为‘root’，此外没有区别。所以只要import了logging库，root就已经创建了，且作为所有Logger的一个属性。</li><li>每个Logger都有一个parent属性，root.parent=None.</li><li>每个Logger都有一个handlers数据和filters数组。</li><li>Logger的callHandlers方法就是调用当前logger.handlers所有handler的handle方法，将record传给它，然后c=c.parent，继续调用父亲的所有handler，除非当前logger.propagate设为False.</li><li>如果不使用basicConfig或者对root添加过任何handler，或者没有调用模块级的logging.debug等函数(它们会自动调用basicConfig)，那么root.handlers也为空。<br>此时还有一个保底的lastResort，默认为_StderrHandler。如果这个lastResort也被设为None，那么就会向stderr写入 ‘No handlers could be found for logger xx’。<br>那么什么这个lastResort会被设为None呢？这是新版本的行为，新版本中如果没有找到任何handler就会使用这个保底的handler，而不是是之前的显示’No handler xx‘警告。</li><li><code>logging.basicConfig</code><br>只有当root.handlers为空时才会起作用。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个例子：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; logging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logger=logging.getLogger(__name__)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logger.setLevel(logging.INFO)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 添加handler&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;handler=logging.FileHandler(&lt;span class=&quot;string&quot;&gt;&#39;hello.log&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;handler.setLevel(logging.INFO)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# handler可以有多个，所以用add&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logger.addHandler(handler)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 设置格式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;formatter=logging.Formatter(&lt;span class=&quot;string&quot;&gt;&#39;[%(asctime)s] [%(levelname)s] %(message)s&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;%H:%M:%S&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# formatter只能有一个&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;logger.setFormatter(formatter)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于库来说，通常使用 &lt;em&gt;__name__&lt;/em&gt; 来获取 Logger对象，然后只添加一个&lt;code&gt;NullHandler&lt;/code&gt;，表示默认不会输出任何log:
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://fafe.me/tags/Python/"/>
    
      <category term="logging" scheme="https://fafe.me/tags/logging/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程基础</title>
    <link href="https://fafe.me/2016/12/25/python-corroutine/"/>
    <id>https://fafe.me/2016/12/25/python-corroutine/</id>
    <published>2016-12-24T16:53:26.000Z</published>
    <updated>2017-01-20T16:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><p>定义协程(coroutine)的两种方式：<code>async def</code>或使用generator实现。<br>基于generator的协程应该使用<code>@asyncio.coroutine</code>修饰，但这并不是严格要求的，基于generator的协程使用<code>yield from</code>语法。<a id="more"></a></p></li><li><p><code>coroutine</code>这个词有两种意思：</p><ol><li>定义协程的<strong>函数</strong><br>使用<code>async def</code>或<code>@asyncio.coroutine</code>。无歧义的称呼是<code>coroutine function</code>,<code>isroutinefunction()</code>返回<code>True</code>。</li><li>调用协程函数获得的<strong>对象</strong><br>这个对象表示一个可结束的<strong>计算</strong>或<strong>I/O操作</strong>。无歧义的称呼是<code>coroutine object</code>,<code>iscoroutine()</code>返回<code>True</code>。</li></ol></li><li><p>协程可以做的事：</p><ul><li><p><code>result = await future</code>或<code>result = yield from future</code><br>暂停协程，直到future完成，然后返回<code>future</code>的结果，或者抛出一个异常。</p></li><li><p><code>result = await coroutine</code> 或 <code>result = yield from coroutine</code><br>等待另一个协程产生结果(或者抛出一个异常)。<code>coroutine</code>表达式必须为对另一个协程的<code>调用</code>。</p></li><li><p><code>return expersssion</code> 产生结果，结果传递给那些使用<code>await</code>或<code>yield from</code>等待此协程的协程。</p></li><li><p><code>raise exception</code> 抛出异常。</p></li></ul></li></ul><h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><ul><li><p><code>asyncio.get_event_loop</code></p></li><li><p><code>asyncio.ensure_future(coro_or_future, *, loop=None)</code><br>将coroutine object包装在future中，返回<code>Task</code>对象。</p></li><li><p><code>BaseEventLoop.run_until_complete(future)</code><br>阻塞，直到future完成，返回future的结果。<br>如果参数是一个<code>coroutine object</code>，则使用<code>ensure_future()</code>包装一下。</p></li></ul><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ol><li><p>添加任务到事件循环中</p></li><li><p>每一次循环，从队列中取出一个任务，对其调用send，让其继续执行，将send的结果继续添加到任务队列中。如果调用send抛出了<code>StopIteration</code>异常，则表示任务已经完成了，则不再添加到队列中。</p></li><li><p><code>await future</code>，future 抛出的<code>StopIteration</code>由await捕获，并从<code>StopIteration</code></p><p>对象的第一参数中获取<code>future</code>的结果，作为await的返回值，此时被等待的<code>future</code>已经完成，继续执行当前coroutine之后的代码。</p><p>如果future没有抛出异常，则future中<code>yield</code>的结果经由这个await(或者yield from)向上传递，一直到调用<code>send</code>的那个语句中(一般是事件循环中)，作为send的返回值。</p><p>所以一直都是最深层次的任务和事件循环在打交道，与途中的await没有关系，只有当最底层的future完成之后，才开始执行其上一层的任务。</p></li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li><p>第一个<code>send(None)</code>或者<code>next(coro)</code>的返回值是什么？</p><p>第一次 send 使 generator 开始执行，直到遇到第一个 yield</p><p>此时 generator 让出执行权，将 yield 表达式的值作为 send 的返回值，此时 generator 内部 yield 左边的赋值并没有进行，而是在这之间就 yield(让步)了。</p><p>第二次调用 send(something), 则从 yield 赋值语句开始恢复，send 的参数作为 yield 的返回值，赋给左边的变量，继续执行。</p></li><li><p>yield 与 yield from 有什么区别？</p><p>函数中的 yield 使函数成为 generator，当 generator 到达末尾时(自然结束或遇到 return 语句)，会抛出<code>StopIteration</code>异常。</p><p>Python3.3 之后，return 语句的参数会成为<code>StopIteration</code>的 value 参数(<code>raise StopIteration(value=something)</code>)。</p><p>普通的由 yield 创造的 generator 一般会忽略 StopIteraion.value，也就是忽略reurn的值，只将StopIteration作为generator exhausted的条件。而<code>yield from</code> 会捕获<code>StopIteraion</code> 异常，并获取其 value 参数，作为自己的返回值。看上去没什么大不了，但却是后来<code>await</code>的基础。</p></li><li><p>？？</p><p>如果yield from future， future 没有 return，那么 future 中 yield 产生的值都会<strong>经过</strong> yield from 向更高层传递，最终到达事件循环，与 yield from 一点关系也没有。当 futurn return时，yield from 很开心，终于不用做传话人了，于是获取 futurn 的结果，作为自己的返回值，也就意味着这个future resolve了，这个异步任务完成了。</p><p>本来使用yield可以产生任意类型的值，yield from都会将其逐步传递到最顶层作为 send 的返回值。但是因为最顶层一般是事件循环，它需要将 send 的结果，继续添加到任务队列中，之后再从队列中将其取出，对其调用 send 方法(或next)让其继续执行。所以这个对象就必须有一些特殊要求，这个要求就是awaitable???? Future? Task?</p></li><li><p>await与yield from的区别？</p><p>await比yield from只多了一步参数检查：await只接受<strong>awaitable</strong>对象，包括：</p><ul><li>一个 <em>native coroutine object</em> returned from <em>native coroutine function</em></li><li><em>generator-based coroutine object</em> returned from a functin decoreated with <code>asyncio.coroutine()</code></li><li>an object with an __await__  method returning an iterator.</li></ul><p>任何 yield from 链都是以 yield 结尾的，这是 Future 实现的基础。每个await 都是被 await链底端的 yield 暂停的。</p></li></ol><h2 id="async-与-await-语法"><a href="#async-与-await-语法" class="headerlink" title="async 与 await 语法"></a>async 与 await 语法</h2><ul><li>async def 函数永远是协程，即使它不包含await表达式</li><li>async 函数中使用 yield 或 yield from 是语法错误</li><li>async def 定义的是 native coroutine，设置了 <code>CO_COROUTINE</code>标志</li><li><em>generator-based coroutine</em> 与 native coroutine 兼容，设置了 <code>CO_ITERABLE_COROUTINE</code> 标志</li><li>在async def 函数外使用 await 是语法错误</li><li>为 await 传递非awaitable对象会报 TypeError</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/" target="_blank" rel="external"></a></li><li><a href="https://docs.python.org/3/library/asyncio.htmll" target="_blank" rel="external">asyncio — Asynchronous I/O, event loop, coroutines and tasks</a></li><li><a href="https://www.python.org/dev/peps/pep-0492/#examples-of-await-expressions" target="_blank" rel="external">PEP 492 – Coroutines with async and await syntax</a></li><li><a href="https://www.python.org/dev/peps/pep-3156/" target="_blank" rel="external">PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义协程(coroutine)的两种方式：&lt;code&gt;async def&lt;/code&gt;或使用generator实现。&lt;br&gt;基于generator的协程应该使用&lt;code&gt;@asyncio.coroutine&lt;/code&gt;修饰，但这并不是严格要求的，基于generator的协程使用&lt;code&gt;yield from&lt;/code&gt;语法。
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://fafe.me/tags/Python/"/>
    
      <category term="协程" scheme="https://fafe.me/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook 初试</title>
    <link href="https://fafe.me/2016/12/18/jupyter-notebook/"/>
    <id>https://fafe.me/2016/12/18/jupyter-notebook/</id>
    <published>2016-12-17T18:39:56.000Z</published>
    <updated>2017-01-20T16:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>pip3 install jupyter --user</code></p><p>Jupyter Notebook的kernel是<code>IPython</code>, 这样Notebook才可以使用<code>Python</code>. 也可以安装kernel, 比如 R, Julia.<a id="more"></a></p><p>Pycharm其实自带了jupyter notebook的支持，而且把包都装好了。新建一个jupyter notebook文件，就相当于打开了一个notebook前端。点运行时会启动server.</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>开启notebook服务器： <code>jupyter notebook</code></p><p><code>jupyter</code>是主命令，用来调用具体的<code>jupyter-notebook</code>程序。如果在<code>PATH</code>中能找到类似<code>jupyter-xxx</code>的程序，那么就可以用<code>jupyter xxx</code>来启动它。<code>jupyter --paths</code>可以显示jupyter一些相关的目录配置。</p><p>这个命令会启动基于Tornado的 notebook服务器，并用默认的浏览器作为客户端打开链接，初始的页面 <em>Notebook Dashboard</em>. </p><p>Notebook Dashboard会列出服务器启动目录下的文件。</p><p>客户端和jupyter kernel通过ZeroMQ传送JSON消息。Notebook前端除了运行代码之外，还会将代码/输出，以及Markdown格式的笔记等保存为 <code>.ipynb</code>后缀的JSON文件，这称为一个notebook文件。</p><h3 id="Notebook使用"><a href="#Notebook使用" class="headerlink" title="Notebook使用"></a>Notebook使用</h3><p><code>Shitf+Enter</code>执行代码并移动到新的单元格</p><p>有返回值的计算结果会有<code>Out[x]</code>的标识，代码中最后一个表达式的值将在输出区域显示。如果希望屏蔽输出，可以在最后一个语句后添加分号：”;”。在Cell中按<code>Tab</code>可以像IPython中一样有自动补全。</p><p>可以修改之前的单元格，对其重新计算，这样可以更新整个文档。</p><p>Cell支持Markdown格式，使用Shift+Enter渲染为富文本。Markdown可以嵌入LaTex, 图片，表格等内容。</p><p>从<code>from IPython.display</code>可以引入许多有用的展示内容，用他们可以在notebook中导入音频，视频，网页等内容。</p><h3 id="魔法命令"><a href="#魔法命令" class="headerlink" title="魔法命令"></a>魔法命令</h3><p>所有<code>%</code>开头的方法，称为魔法命令，也就是IPython内置的一些方法。<code>%</code>称为line magic，对一行起作用，<code>%%</code>针对多行起作用。</p><p>通过<code>%lsmagic%</code>查看所有的魔法命令。使用<code>?</code>可以查看命令的信息，比如<code>%alias?</code>。</p><p>Notebook内置支持matplotlib, 用<code>%matplotlib</code>魔术方法调用。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://ipython.readthedocs.io/en/stable/interactive/python-ipython-diff.html" target="_blank" rel="external">IPython</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;&lt;code&gt;pip3 install jupyter --user&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Jupyter Notebook的kernel是&lt;code&gt;IPython&lt;/code&gt;, 这样Notebook才可以使用&lt;code&gt;Python&lt;/code&gt;. 也可以安装kernel, 比如 R, Julia.
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://fafe.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Shell 基础</title>
    <link href="https://fafe.me/2016/12/03/shell-basic/"/>
    <id>https://fafe.me/2016/12/03/shell-basic/</id>
    <published>2016-12-03T15:45:38.000Z</published>
    <updated>2017-01-20T16:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>source</p><p>也可以简写为 <code>.</code> ，这也是通用的兼容写法</p><p>在当前的shell中执行文件中命令，所以文件中的命令可以读取到当前shell中的变量(不一定是环境变量)，等同于在命令行一条一条地敲入命令执行。<a id="more"></a></p></li><li><p>export<br>将变量导出到<strong>当前进程的</strong>环境变量中，后续执行命令都可以读取到这些变量。如果用新的bash进程来export，那么改变的是新进程的环境变量，当执行结束后，本来的shell不会(父进程)的环境变量不会改变。<br>使用source之后，才在shell，父进程中执行，所以改变了父进程的环境变量，于是在shell中执行的后续的命令都会继承这个环境变量。</p></li><li><p>子进程会继承哪些东西？<br>当前目录？环境变量？</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;source&lt;/p&gt;
&lt;p&gt;也可以简写为 &lt;code&gt;.&lt;/code&gt; ，这也是通用的兼容写法&lt;/p&gt;
&lt;p&gt;在当前的shell中执行文件中命令，所以文件中的命令可以读取到当前shell中的变量(不一定是环境变量)，等同于在命令行一条一条地敲入命令执行。
    
    </summary>
    
      <category term="Linux" scheme="https://fafe.me/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://fafe.me/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中的 runlevel</title>
    <link href="https://fafe.me/2016/12/02/linux-runlevel/"/>
    <id>https://fafe.me/2016/12/02/linux-runlevel/</id>
    <published>2016-12-01T20:27:13.000Z</published>
    <updated>2017-01-20T16:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>6个典型的运行级别：</p><ul><li>0 停机，关机</li><li>1 单用户，无网络连接，不运行守护进程，不允许非超级用户登录</li><li>2 多用户，无网络连接，不运行守护进程</li><li>3 多用户，正常启动系统</li><li>4 用户自定义</li><li>5 多用户，带图形界面</li><li>6 重启<a id="more"></a></li></ul><p>现在的Linux好像都用 systemd 中target来代替runlevel了，但仍然兼容runlevel，并且会将runlevel映射到相应的target中，比如：0        </p><table><thead><tr><th style="text-align:center">Runlevel</th><th style="text-align:center">Target</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">poweroff.target</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">rescue.target</td></tr><tr><td style="text-align:center">2, 3, 4</td><td style="text-align:center">multi-usr.target</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">graphical.target</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reboot.target</td></tr></tbody></table><p>/etc/rc0.d/ /etc/rc1.d 这些目录对应不同的运行级别，系统启动时运行相应的目录中的脚本来启动服务。这些目录中都是指向/etc/init.d/目录中脚本的软连接。</p><p>/etc/init.d 中的脚本，一般称为服务(service)?</p><p>/etc/rcX.d/中的链接，系统会杀掉K开头的服务，按照数字从小到大启动S开头的服务。</p><p>/etc/rc.local存在于多个runlevel中，所以基本上只要机器开机这个脚本就会自动运行。一般情况下这个脚本为空，如有需要将一些程序加入开机自启，可以讲程序命令添加到这个脚本中。</p><p>查看运行级别： runlevel</p><p>运行级别是互斥的，无法同时运行多个运行级别。</p><p>本来应该由init进程读取/etc/inittab确定运行级别，但现在还有都没有这个文件了。</p><h3 id="upstart机制"><a href="#upstart机制" class="headerlink" title="upstart机制"></a>upstart机制</h3><p>/etc/init/是upstart寻找作业配置文件的地方</p><h3 id="systemd机制"><a href="#systemd机制" class="headerlink" title="systemd机制"></a>systemd机制</h3><p>service <script> COMMAND [options] 实际上是运行一个sysvinit程序或者upstart作业，比如service nginx start实际执行的命令是 /etc/init.d/nginx start，start命令实际是由nginx这个脚本来做的。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li></ol><ol><li><a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html</a></li></ol></script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6个典型的运行级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 停机，关机&lt;/li&gt;
&lt;li&gt;1 单用户，无网络连接，不运行守护进程，不允许非超级用户登录&lt;/li&gt;
&lt;li&gt;2 多用户，无网络连接，不运行守护进程&lt;/li&gt;
&lt;li&gt;3 多用户，正常启动系统&lt;/li&gt;
&lt;li&gt;4 用户自定义&lt;/li&gt;
&lt;li&gt;5 多用户，带图形界面&lt;/li&gt;
&lt;li&gt;6 重启
    
    </summary>
    
      <category term="Linux" scheme="https://fafe.me/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://fafe.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的时间模块</title>
    <link href="https://fafe.me/2016/10/02/python-time-datetime/"/>
    <id>https://fafe.me/2016/10/02/python-time-datetime/</id>
    <published>2016-10-02T06:38:06.000Z</published>
    <updated>2017-01-20T16:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>time 模块比较简单, 常用的函数只有几个, 但是这个模块中的函数名都很奇怪, 估计是模仿 *inx 的时间函数风格, 也查不到到底是什么的缩写, 那就不管它好了.<br><a id="more"></a></p><h5 id="time-sleep-seconds"><a href="#time-sleep-seconds" class="headerlink" title="time.sleep(seconds)"></a>time.sleep(seconds)</h5><p>使程序的执行推迟一定时间, seconds 可以为小数.</p><h5 id="time-gmtime-seconds-None"><a href="#time-gmtime-seconds-None" class="headerlink" title="time.gmtime(seconds=None)"></a>time.gmtime(seconds=None)</h5><p>把 从<code>Epoch</code>之后经过的秒数 转换为time tuple (<code>time.struct_time</code>类型), 未提供<code>seconds</code>则使用当前的时间戳. (<code>time.time()</code>的返回值?)</p><blockquote><p><strong>Unix time</strong> (also known as <strong>POSIX time</strong> or <strong>Epoch time</strong>) is a system for describing instants in time, defined as the number of seconds that have elapsed since 00:00:00 <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time" target="_blank" rel="external">Coordinated Universal Time</a> (UTC), Thursday, 1 January 1970</p><footer><strong>Wikipedia</strong><cite><a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="external">en.wikipedia.org/wiki/Unix_time</a></cite></footer></blockquote><p>所以常说的时间戳或者 <code>Epoch</code> , 都是指的 UTC 时间, 如果要转换为当地时间, 则需要根据时区的偏移量进行运算.</p><h5 id="time-localtime-seconds-None"><a href="#time-localtime-seconds-None" class="headerlink" title="time.localtime(seconds=None)"></a>time.localtime(seconds=None)</h5><p>与<code>gmtime()</code>功能基本相同, 但是会先将当前时间戳转换为当前的 UTC 时间, 然后根据本地时区对UTC时间的偏移量, 计算得到本地的当前时间. (先使用<code>gmtime()</code>, 然后再加上偏移量?)</p><h5 id="time-mktime"><a href="#time-mktime" class="headerlink" title="time.mktime()"></a>time.mktime()</h5><p>将 本地时间的 time tuple 转为 seconds since Epoch, 是 <code>time.localtime()</code>的逆操作, 估计是现根据本地时间得到 UTC 的 time tuple, 然后计算 seconds.</p><h5 id="time-ctime-与-time-asctime"><a href="#time-ctime-与-time-asctime" class="headerlink" title="time.ctime() 与 time.asctime()"></a>time.ctime() 与 time.asctime()</h5><p>这两个函数将 秒数/time tuple 转换为字符串, 基本没用, 因为不可以自己定义格式.</p><h5 id="time-strftime-与-time-strptime"><a href="#time-strftime-与-time-strptime" class="headerlink" title="time.strftime() 与 time.strptime()"></a>time.strftime() 与 time.strptime()</h5><p>一个根据格式输出time tuple 的字符串表示, 一个根据格式把字符串解析为 time tuple.</p><h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://www.jianshu.com/p/113bd56f7b56" target="_blank" rel="external">python中datetime模块详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;time&quot;&gt;&lt;a href=&quot;#time&quot; class=&quot;headerlink&quot; title=&quot;time&quot;&gt;&lt;/a&gt;time&lt;/h3&gt;&lt;p&gt;time 模块比较简单, 常用的函数只有几个, 但是这个模块中的函数名都很奇怪, 估计是模仿 *inx 的时间函数风格, 也查不到到底是什么的缩写, 那就不管它好了.&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://fafe.me/tags/Python/"/>
    
      <category term="时间处理" scheme="https://fafe.me/tags/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Arrow: better dates and times for Python</title>
    <link href="https://fafe.me/2016/10/02/python-arrow/"/>
    <id>https://fafe.me/2016/10/02/python-arrow/</id>
    <published>2016-10-01T16:22:47.000Z</published>
    <updated>2017-01-20T16:17:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中时间处理的库太多, 基本的有<code>time</code>, 复杂的有<code>datetime</code>, 日历处理有<code>Calendar</code>, 各种时区信息的库… 各个库中函数的命名也十分让人崩溃,比如<code>time</code>中的<code>ctime()</code>, <code>asctime()</code>, <code>strftime()</code>, <code>strptime()</code>, <code>localtime()</code>你能记得住这些函数分别接受什么参数, 起什么作用吗? 我觉得挺崩溃的. <a id="more"></a></p><p>Arrow 是一个第三方时间日期处理库, 提供了非常简洁优雅的接口, 我们首先来分析一下这个库的功能模块.</p><h4 id="api-py"><a href="#api-py" class="headerlink" title="api.py"></a>api.py</h4><p>向外提供了四个接口: <code>get()</code>, <code>now()</code>, <code>utcnow()</code>, <code>factory()</code>. 前三个都是代理到 <code>ArrowFactory</code> 相应的方法上, <code>factory()</code> 返回一个 <code>ArrowFactory</code> 实例.</p><h4 id="facotry-py"><a href="#facotry-py" class="headerlink" title="facotry.py"></a>facotry.py</h4><p><code>ArrowFactory</code> 干的事很少, 还是那三个工厂方法 <code>get()</code>,<code>now()</code>, <code>utcnow()</code>, 都返回一个 <code>Arrow</code> 实例, 代表一个时间点.<br><code>get()</code>由<code>ArrowFactory</code>实现, 其他方法由<code>Arrow</code>实现.</p><h4 id="arrow-py"><a href="#arrow-py" class="headerlink" title="arrow.py"></a>arrow.py</h4><p><code>Arrow</code> 实现了 <code>datetime</code> 接口, 是一个标准的 <code>datetime</code> 对象, 而且增加了许多功能.</p><h5 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数:"></a>1.构造函数:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>, microsecond=<span class="number">0</span>, tzinfo=None)</span></span></div></pre></td></tr></table></figure><p>如果<code>tzinfo == None</code>, 则默认为 UTC 时间.</p><p><code>tzinfo</code> 参数接受四种形式:</p><ul><li>A <code>tzinfo</code> object.</li><li>A <code>str</code> describing a timezone, similar to ‘US/Pacific’, or ‘Europe/Berlin’.</li><li>A <code>str</code> in ISO-8601 style, as in ‘+07:00’.</li><li>A <code>str</code>, one of the following:  ‘local’, ‘utc’, ‘UTC’.</li></ul><h5 id="2-Arrow-utcnow-与-Arrow-now-tzinfo-None"><a href="#2-Arrow-utcnow-与-Arrow-now-tzinfo-None" class="headerlink" title="2. Arrow.utcnow() 与 Arrow.now(tzinfo=None)"></a>2. Arrow.utcnow() 与 Arrow.now(tzinfo=None)</h5><p>这两个工厂方法比较简单. <code>utcnow()</code>调用<code>datatime.utcnow()</code>获取 UTC 时间, 然后构造<code>Arrow</code>对象.</p><p><code>now()</code>接受一个<code>tzinfo</code>参数, 如果为空则默认为 <code>dateutil_tz.tzlocal()</code>, 即本地时间.</p><h5 id="3-Arrow-get"><a href="#3-Arrow-get" class="headerlink" title="3. Arrow.get()"></a>3. Arrow.get()</h5><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://crsmithdev.com/arrow/" target="_blank" rel="external">Arrow: better dates and times for Python</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 中时间处理的库太多, 基本的有&lt;code&gt;time&lt;/code&gt;, 复杂的有&lt;code&gt;datetime&lt;/code&gt;, 日历处理有&lt;code&gt;Calendar&lt;/code&gt;, 各种时区信息的库… 各个库中函数的命名也十分让人崩溃,比如&lt;code&gt;time&lt;/code&gt;中的&lt;code&gt;ctime()&lt;/code&gt;, &lt;code&gt;asctime()&lt;/code&gt;, &lt;code&gt;strftime()&lt;/code&gt;, &lt;code&gt;strptime()&lt;/code&gt;, &lt;code&gt;localtime()&lt;/code&gt;你能记得住这些函数分别接受什么参数, 起什么作用吗? 我觉得挺崩溃的.
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://fafe.me/tags/Python/"/>
    
      <category term="arrow" scheme="https://fafe.me/tags/arrow/"/>
    
      <category term="时间" scheme="https://fafe.me/tags/%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>PlantUML: 用程序员的方式画图</title>
    <link href="https://fafe.me/2016/10/01/hexo-plantuml/"/>
    <id>https://fafe.me/2016/10/01/hexo-plantuml/</id>
    <published>2016-10-01T05:31:03.000Z</published>
    <updated>2017-01-20T16:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PlantUML-简介"><a href="#PlantUML-简介" class="headerlink" title="PlantUML 简介"></a>PlantUML 简介</h3><p>PlantUML 是一个画图脚本语言，用它可以快速地画出：</p><ul><li>时序图</li><li>流程图</li><li>用例图</li><li>状态图</li><li>组件图<a id="more"></a></li></ul><p>PlantUML 本体是一个 <code>plantuml.jar</code>文件, 依赖于 <a href="http://www.graphviz.org/" target="_blank" rel="external">graphviz</a>.</p><p>graphviz 是一个开源的图片渲染库, 安装了这个库才能在 Windows 下把脚本转换为图片(sequence diagram 和 activity beta diagrams 可以不需要).</p><p><a href="http://www.graphviz.org/Download_windows.php" target="_blank" rel="external">下载</a> graphviz之后, 设置<code>GRAPHVIZ_DOT</code>环境变量为<code>path/to/graphviz/release/dot.exe</code>, 使 plantuml 能够找到 <code>dot.exe</code>, 然后使用<code>java -jar ./plantuml.jar -testdot</code> 测试配置是否成功.</p><p>配置完成之后, 新建文件, 在其中写入简单的 Demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@startuml</div><div class="line">Alice -&gt; Bob: test</div><div class="line">@enduml</div></pre></td></tr></table></figure><p>然后执行命令 <code>java -jar plantuml.jar demo.txt</code> 即可生成图片. 也可以直接双击 <code>plantuml.jar</code>文件打开GUI窗口来操作.</p><p>PlantUML 几乎可以集成到任何编辑器/IDE/文档工具中, 比如 Sublime Text 中有 <a href="https://github.com/jvantuyl/sublime_diagram_plugin" target="_blank" rel="external">PlantUML for Sublime</a> ,  Intellij IDEA , Eclipse, Chrome 中都有相应的插件.在<a href="http://plantuml.com/running" target="_blank" rel="external">这里</a>查看如何在你当前的使用的软件中集成 PlantUML.</p><h3 id="在-Hexo-中使用-PlantUML"><a href="#在-Hexo-中使用-PlantUML" class="headerlink" title="在 Hexo 中使用 PlantUML"></a>在 Hexo 中使用 PlantUML</h3><p>Typora 自带支持 <code>sequence</code>, <code>flow chart</code> 等画图工具, 但 Hexo 自身的 Markdown 解析器不支持, 所以需要安装相应的 tag 插件.</p><p><code>hexo-tag-plantuml</code> 插件的语法与 Typora 自带的 sequence 语法相似, 看上去都很简洁. 使用<code>npm install hexo-tag-plantuml --save</code> 安装之后, <strong>不用修改任何_config.yml配置</strong>, 直接在 Markdown 文件中使用 {% plantuml %} {% endplantuml %}  标签就可以了.</p><blockquote><p>这里不太明白的就是 Hexo 的插件机制, 不知道插件如何才能起作用:question:</p></blockquote><p><code>hexo-tag-plantuml</code> 其实使用的是 PlantUML 提供的<a href="http://www.plantuml.com/plantuml/" target="_blank" rel="external">在线服务</a>, 只是简单地将标签包裹的代码传给服务器, 获取生成的链接, 生成 <code>img</code>标签替换原来的代码区域.</p><h3 id="PlantUML-语法"><a href="#PlantUML-语法" class="headerlink" title="PlantUML 语法"></a>PlantUML 语法</h3><p>TODO</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://plantuml.com/PlantUML_Language_Reference_Guide.pdf" target="_blank" rel="external">PlanUML 官方文档</a> </li></ul><ul><li><a href="http://www.jianshu.com/p/e92a52770832" target="_blank" rel="external">使用 Sublime + PlantUML 高效地画图</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PlantUML-简介&quot;&gt;&lt;a href=&quot;#PlantUML-简介&quot; class=&quot;headerlink&quot; title=&quot;PlantUML 简介&quot;&gt;&lt;/a&gt;PlantUML 简介&lt;/h3&gt;&lt;p&gt;PlantUML 是一个画图脚本语言，用它可以快速地画出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时序图&lt;/li&gt;
&lt;li&gt;流程图&lt;/li&gt;
&lt;li&gt;用例图&lt;/li&gt;
&lt;li&gt;状态图&lt;/li&gt;
&lt;li&gt;组件图
    
    </summary>
    
      <category term="工具" scheme="https://fafe.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="https://fafe.me/tags/hexo/"/>
    
      <category term="plantuml" scheme="https://fafe.me/tags/plantuml/"/>
    
  </entry>
  
  <entry>
    <title>HTTP for Human: 深入研究 Requests</title>
    <link href="https://fafe.me/2016/09/30/requests-http-for-human/"/>
    <id>https://fafe.me/2016/09/30/requests-http-for-human/</id>
    <published>2016-09-29T16:00:00.000Z</published>
    <updated>2017-01-20T16:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇学习 Requests 的随笔.</p><h3 id="Python-回顾"><a href="#Python-回顾" class="headerlink" title="Python 回顾"></a>Python 回顾</h3><ul><li><p><code>bytearray</code>是一个字节数组, 数组的内容是可变的, 数组中的每一个元素都是 <code>[0, 256)</code>之间的整数<br>定义为: <code>bytearray([source[, encoding[, errors]]])</code> <a id="more"></a><br>其中<code>source</code>参数有几种情况:</p><ul><li>If it is a string, you must also give the encoding (and optionally, errors) parameters; <code>bytearray()</code> then converts the string to bytes using <code>str.encode()</code>.</li><li>If it is an integer, the array will have that size and will be initialized with <code>null</code> bytes.</li><li>If it is an object conforming to the <em>buffer</em> interface, a read-only buffer of the object will be used to initialize the bytes array.</li><li>If it is an iterable, it must be an iterable of integers in the range 0 &lt;= x &lt; 256, which are used as the initial contents of the array.</li></ul><p><code>bytearray</code>是一个<code>Mutable Sequence</code>, 所以支持大多数<code>list</code>的操作:<br><img src="/images/list-operation.png" alt="list-operation"></p><p>(<strong>注意</strong>: 图片放在<code>source/images</code>中, 会被拷贝到<code>public/images</code>中, 在Markdown中绝对引用 <code>/images/xxx.jpg</code>才能显示图片)</p></li><li><p><code>bytes</code>是一个不可变版本的<code>bytearray</code><br><code>bytes</code>对象可以通过 字面量(literal) 直接创建: <code>b&#39;&#39;</code>或者<code>B&#39;&#39;</code></p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3></li></ul><p>我们最常使用的<code>requests.get()</code>, <code>requests.post()</code> 等方法都是简便的 API, 传递给这些 API 的参数被用来构造<code>Request</code>对象.</p><p><code>Request</code> 对象有两种形态, 一种是普通的对象形态, 一种是经过 <code>prepare</code> 之后转换为 <code>PreparedRequest</code>, 才是真正可以被发送的对象, 其中的<code>body</code>, <code>header</code>, <code>cookie</code> 等都已经转换成符合HTTP规范的字符串了, 准备好在网络上传输了.</p><p><code>PreparedRequest</code>对象只是将要被发送的内容, 而自身没有发送的功能. 发送的功能是由<code>session</code>对象提供的, <code>session.send()</code>方法会调用<code>adapter.send()</code>, 将请求真正地发送出去.</p><p>请求被发送之后收到服务器的响应, 响应被<code>adapter</code>解析为<code>Response</code>对象, 从<code>requests.get()</code>, <code>requests.post()</code>等方法中返回. 调用者可以用<code>Response</code>中获取需要的信息.</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><ol><li><p>普通青年的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">resp = requests.get(<span class="string">'http://www.baidu.com'</span>)</div><div class="line">print(resp.content)</div></pre></td></tr></table></figure></li><li><p>作死青年的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s = requests.Session()</div><div class="line">s.headers.update(&#123;<span class="string">'laozizuidiao'</span>: <span class="string">'laozizuidiao'</span>&#125;)</div><div class="line">s.get(<span class="string">'http://www.gov.cn'</span>)</div><div class="line">s.get(<span class="string">'http://www.beijing.gov.cn'</span>)</div></pre></td></tr></table></figure></li><li><p>文艺青年的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> s = Session()</div><div class="line"> req = Request(<span class="string">'GET'</span>, url,</div><div class="line">    data=data,</div><div class="line">    headers=header</div><div class="line"> )</div><div class="line"> prepped = req.prepare()</div><div class="line"> //prepped = s.prepare_request(req) 这样可以把 session 中的已有的状态添加到这个 req 中</div><div class="line">resp = s.send(prepped,</div><div class="line">    stream=stream,</div><div class="line">    verify=verify,</div><div class="line">    proxies=proxies,</div><div class="line">    cert=cert,</div><div class="line">    timeout=timeout</div><div class="line">)</div><div class="line"></div><div class="line">print(resp.content)</div></pre></td></tr></table></figure></li></ol><p>下面我们逐个分析 Requests 的组成部分.</p><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p><code>Request</code>其实是一个没什么用的类, 我还不怎么明白为什么要设计这个类.</p><p><code>Request</code>继承自<code>RequestHookMixin</code>, 自身只有一个方法<code>prepare()</code>, 作用就是新建一个<code>PreparedRequest</code>对象, 然后将自己的那些参数传给<code>PreparedReques.prepare()</code>, 准备好一个可以发送的对象</p><p>我们直接使用的API, 都是先用我们传递的参数构造这个对象.</p><p>下面我们来分析一下常用的几个参数: TODO</p><p><code>params</code></p><p><code>data</code></p><p><code>headers</code></p><p><code>cookies</code></p><p><code>allow_redirects</code></p><p><code>auth</code></p><p><code>json</code></p><p><code>stream</code></p><h3 id="PreparedRequest"><a href="#PreparedRequest" class="headerlink" title="PreparedRequest"></a>PreparedRequest</h3><p><code>PreparedRequest</code>是请求过程中最重要的一个类, 而这个类中最重要的就是它的各个<code>prepare_xxx</code>方法.</p><p>TODO</p><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>❓<code>Response</code> 实际是由<code>adapter</code>生成的, <code>adapter</code>是什么?</p><p>下面分析一下<code>Response</code>常用的属性:</p><p><code>.status_code</code> 服务器响应的状态码</p><p><code>.reason</code> 原因短语</p><p><code>.url</code> TODO</p><p><code>.encoding</code> </p><p><code>.headers</code> 是一个<code>CaseInsensitiveDict</code></p><p><code>.cookies</code>初始化为<code>cookiejar_from_dict({})</code>, 这个函数的定义为:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cookiejar_from_dict</span><span class="params">(cookie_dict, cookiejar=None, overwrite=True)</span>:</span></div><div class="line">    <span class="string">"""Returns a CookieJar from a key/value dictionary.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    :param cookie_dict: Dict of key/values to insert into CookieJar.</span></div><div class="line"><span class="string">    :param cookiejar: (optional) A cookiejar to add the cookies to.</span></div><div class="line"><span class="string">    :param overwrite: (optional) If False, will not replace cookies</span></div><div class="line"><span class="string">        already in the jar with new ones.</span></div><div class="line"><span class="string">    """</span></div></pre></td></tr></table></figure><p>也就是说将一个<code>dict</code>添加到一个<code>cookiejar</code>中, 如果<code>cookiejar</code>为<code>None</code>, 则新建一个空的<code>RequestCookieJar</code></p><p><code>.request</code>是请求时的<code>PreparedRequest</code>对象</p><p><code>.elapsed</code> TODO</p><p><code>.content</code> 是没有 <code>decode</code>过的<strong>字节串</strong>, 而<code>.text</code> 会自动根据<code>.encoding</code> 中的编码自动将<code>content</code>解码为<code>str</code>. 如果手动改变<code>.encoding</code>, 那么重新读取<code>.text</code>时也会重新解码</p><p>默认情况, 请求之后响应体会立即被下载. 如果设置 <code>stream=True</code> , 则直到访问 <code>Response.content</code>时才会下载<br>但是设置<code>stream=True</code>, Requests 无法自动将连接释放到连接池中, 除非消耗了所有数据或者显式地调用<code>Response.close()</code></p><p><code>.history</code>是一个<code>list</code> TODO</p><p><code>Reponse</code>的核心就是<code>.raw</code>, <code>iter_content()</code>依次从<code>raw</code>中<code>read</code>数据, 而<code>iter_lines</code>, <code>.content</code> , <code>__iter__()</code>都直接依赖于<code>iter_content()</code>, <code>.text</code>依赖于<code>.content</code>, <code>.json()</code>依赖于<code>.text</code></p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>重头戏, 好好说说. TODO</p><p>在方法级使用的参数(比如<code>cookies</code>)的优先级高于会话级, 但是在方法内使用的参数不会在之后的请求中保留.</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Requests 中默认使用的<code>RequestCookieJar</code> 继承自 <code>cookielib.CookieJar</code>, 而 Python3 中 <code>cookielib</code>已被移到<code>http.cookiejar</code>中.</p><p>为了适配<code>http.cookiejar.CookieJar</code>的接口, <code>requests.cookies</code>又使用了<code>MockRequest</code>, <code>MockResponse</code>, 而<code>http.cookiejar</code>的代码相当复杂, 实在是搞不懂.</p><p><code>RequestCookieJar</code>为<code>http.cookiejar.CookieJar</code>提供了<code>dict</code>的访问接口. Requests 的所有代码都可以无障碍地使用<code>cookielib.CookieJar</code>的子类, 比如 <code>LWPCookieJar</code>, <code>FileCookieJar</code>.</p><p><strong>CookiePolicy</strong></p><p>该类的主要功能是收发cookie, 即确保正确的cookie发往对应的域名, 反之一样.</p><p><strong>DefaultCookiePolicy</strong></p><p>实现了<code>CookiePolicy</code>接口.</p><p><strong>Cookie</strong></p><p>可以看成一条 cookie 数据.<br>有好几种版本的 cookie 吗? Netscape 和 RFC2965 ? 相应的头部分别是 Set-Cookie 和 Set-Cookie2</p><p><strong>CookieJar</strong></p><p>很多条 cookie 数据的集合, 是我们主要的操作对象, 里面有一系列的方法支持更细致的操作. Requests 的 cookie 主要依赖于此类.</p><p><strong>FileCookieJar</strong></p><p>该类继承自<code>CookieJar</code>，<code>CookieJar</code>只是在内存中完成自己的生命周期，<code>FileCookieJar</code>的子类能够实现数据持久化，定义了<code>save</code>、<code>load</code>、<code>revert</code>三个接口</p><p><strong>LWPCookieJar</strong></p><p><code>Response.cookies</code> 默认是<code>RequestCookieJar</code>, 因为一般不会手动构造<code>Response</code>, 都是由<code>HTTPAdapter.build_response()</code>方法构建的, 所以<code>Response.cookies</code>基本永远都是<code>RequestCookieJar</code>, 用户可以方便的使用. 而<code>Session.cookies</code> 可以由用户随意替换, 使用<code>LWPCookieJar</code>等已经实现了<code>load()</code>,<code>save()</code>等方法的 cookie 比较方便.</p><p><strong>MozillaCookieJar</strong></p><h3 id="Auth"><a href="#Auth" class="headerlink" title="Auth"></a>Auth</h3><p>各个API都有<code>auth</code>参数, 这个参数可以是一个<code>(user, pass)</code> 这样的 2-tuple, 也可以是一个 callable.</p><p>这个 callable 接受 <code>PreparedRequest</code>对象作为参数, 可以在发送之前修改请求(比如说添加 Authorization 头部). <code>requests.auth</code>中提供了两个常用的验证方法:<code>HTTPBasicAuth</code>和<code>HTTPDigestAuth</code>, 其他自定义的身份验证机制一般继承自<code>requests.auth.AuthBase</code> 类, 这个类虽然什么也没做, 但是语义化比较好.</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>我自己还没明白怎么用.</p><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>非常重要的基础类, 使用<code>urllib3</code>提供发送功能, 很多概念不太懂, 日后再说. :smile:</p><p>Python3 中 urllib 和 urllib2 合并为 urllib, urllib3是一个第三方库, 是对<code>httplib</code>的包装, 发请求的时候，拼凑http请求, 收到回复的时候,解析response,timeout 也是用httplib 库的timeout参数, requests 内部集成了 urllib3.</p><p><img src="/images/python_lib_urllib3_implements.png" alt="urllib3实现"></p><img src="http://www.plantuml.com/plantuml/svg/AyaioKbLo4ZDoSddKYfABInDBIufrajFBT7GL5BGjLD0Y44PG74hBcoY8CN1gSN5cVbvg6en1HMGrHQdvgMWAeIAW5LvX8G4EAOa5fIa5Y6fn2AAeJgfD3Cd9RuejRWWFwyu5QGF91i4vGC0"><p><code>Session.send()</code>调用<code>HTTPAdapter.send()</code>, <code>HTTPAdapter.send()</code>从<code>urllib3</code>中获取一个<code>connection</code>, 然后调用其<code>urlopen</code>或者<code>HTTPResponse.fromhttplib</code>得到一个<code>HTTPResponse</code>对象. 然后调用<code>Adapter.build_response()</code>, 从<code>HTTPResponse</code>中取出各种数据构造<code>Requests.Response</code>, 将<code>Requests.Response.raw</code>设为这个<code>HTTPResponse</code>对象, 从<code>HTTPResponse</code>中取出<code>cookie</code>添加到<code>Response.cookie</code>中. 然后<code>Session.send()</code>再一次从<code>HTTPRespnse</code>中获取<code>cookie</code>, 添加到自己的<code>Session.cookie</code>中.</p><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p><a href="https://github.com/kennethreitz/requests/issues/2266" target="_blank" rel="external">issue #2266</a> 中说, 会将 <code>util.get_encodings_from_content</code>这样的方法移到<code>requests-toolbelt</code>中, 使得 requests 更专注于 HTTP 而不是 HTML.</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://www.jianshu.com/p/0c0502dfecea" target="_blank" rel="external">requests源码浅析</a></li><li><a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external">Requests: HTTP for Humans</a></li><li><a href="https://my.oschina.net/sukai/blog/611451" target="_blank" rel="external">python中urllib, urllib2,urllib3, httplib,httplib2, request的区别</a></li><li><a href="http://xwl-note.readthedocs.io/en/latest/software/python-lib/urllib3.html" target="_blank" rel="external">urllib3</a></li><li><a href="http://www.jianshu.com/p/b0e386361570" target="_blank" rel="external">requests 如何自动识别编码</a></li><li><a href="https://blog.phpgao.com/python-cookielib.html" target="_blank" rel="external">python中的cookielib的使用方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇学习 Requests 的随笔.&lt;/p&gt;
&lt;h3 id=&quot;Python-回顾&quot;&gt;&lt;a href=&quot;#Python-回顾&quot; class=&quot;headerlink&quot; title=&quot;Python 回顾&quot;&gt;&lt;/a&gt;Python 回顾&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;bytearray&lt;/code&gt;是一个字节数组, 数组的内容是可变的, 数组中的每一个元素都是 &lt;code&gt;[0, 256)&lt;/code&gt;之间的整数&lt;br&gt;定义为: &lt;code&gt;bytearray([source[, encoding[, errors]]])&lt;/code&gt;
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://fafe.me/tags/Python/"/>
    
      <category term="requests" scheme="https://fafe.me/tags/requests/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(三): 适配器模式</title>
    <link href="https://fafe.me/2016/09/29/adapter-pattern/"/>
    <id>https://fafe.me/2016/09/29/adapter-pattern/</id>
    <published>2016-09-29T13:18:06.000Z</published>
    <updated>2017-09-15T09:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-回顾"><a href="#Java-回顾" class="headerlink" title="Java 回顾"></a>Java 回顾</h2><ul><li><code>String</code> 内部实现是一个 <code>char</code> 数组</li><li><code>String</code> 可以由<code>char[]</code> ,<code>int[]</code>, <code>byte[]</code> 生成, 其中<code>char</code>代表每一个字符, <code>int</code>代表一个<code>code point</code>, <code>byte</code> 需要根据相应的 <code>charset</code> 解码为<code>char</code>  <a id="more"></a><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2></li></ul><ol><li>新旧两个接口</li><li>实现旧接口的对象无法在支持新接口的设备上使用</li><li>新建一个转换器(adapter), 实现新的接口, 内部聚合一个旧接口的对象, 将对新接口的所有调用全部委托到旧的接口上去.</li></ol><h2 id="讲课内容"><a href="#讲课内容" class="headerlink" title="讲课内容"></a>讲课内容</h2><ul><li>DIP 接口由高层定义, 低层实现</li><li>类适配器, 使用继承, 只能适配一个类</li><li>对象适配器, 使用聚合</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-回顾&quot;&gt;&lt;a href=&quot;#Java-回顾&quot; class=&quot;headerlink&quot; title=&quot;Java 回顾&quot;&gt;&lt;/a&gt;Java 回顾&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt; 内部实现是一个 &lt;code&gt;char&lt;/code&gt; 数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt; 可以由&lt;code&gt;char[]&lt;/code&gt; ,&lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt;byte[]&lt;/code&gt; 生成, 其中&lt;code&gt;char&lt;/code&gt;代表每一个字符, &lt;code&gt;int&lt;/code&gt;代表一个&lt;code&gt;code point&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt; 需要根据相应的 &lt;code&gt;charset&lt;/code&gt; 解码为&lt;code&gt;char&lt;/code&gt;
    
    </summary>
    
      <category term="编程" scheme="https://fafe.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="设计模式" scheme="https://fafe.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="https://fafe.me/tags/java/"/>
    
      <category term="适配器模式" scheme="https://fafe.me/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
